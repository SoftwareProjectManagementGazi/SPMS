import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import datetime, timedelta
from jose import jwt

from app.domain.entities.user import User
from app.domain.entities.project import Project, Methodology
from app.domain.entities.task import Task, TaskPriority
from app.infrastructure.database.repositories.user_repo import SqlAlchemyUserRepository
from app.infrastructure.database.repositories.project_repo import SqlAlchemyProjectRepository
from app.infrastructure.database.repositories.task_repo import SqlAlchemyTaskRepository
from app.infrastructure.config import settings
from app.infrastructure.database.models.user import UserModel # For creation if repo expects entity

# Helper to generate token
def create_test_token(email: str) -> str:
    expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode = {"sub": email, "exp": expire}
    return jwt.encode(to_encode, settings.JWT_SECRET, algorithm=settings.JWT_ALGORITHM)

@pytest.mark.asyncio
async def test_access_protected_route_without_token(client: AsyncClient):
    response = await client.get("/api/v1/projects/")
    assert response.status_code == 401
    assert response.json() == {"detail": "Not authenticated"}

@pytest.mark.asyncio
async def test_delete_other_user_project(client: AsyncClient, db_session: AsyncSession):
    # Initialize real repositories with the test session
    user_repo = SqlAlchemyUserRepository(db_session)
    project_repo = SqlAlchemyProjectRepository(db_session)

    # 1. Create two users
    # Note: IDs are auto-generated by DB, so we don't set them manually usually.
    # But repositories accept domain entities.
    
    owner = User(email="owner@example.com", password_hash="hashed_pw", full_name="Owner", is_active=True)
    attacker = User(email="attacker@example.com", password_hash="hashed_pw", full_name="Attacker", is_active=True)
    
    created_owner = await user_repo.create(owner)
    created_attacker = await user_repo.create(attacker)

    # 2. Create a project for the owner
    project = Project(
        key="OWN",
        name="Owner Project",
        start_date=datetime.now(),
        methodology=Methodology.SCRUM,
        manager_id=created_owner.id # Use the DB-generated ID
    )
    created_project = await project_repo.create(project)

    # 3. Attacker logs in (Create token)
    token = create_test_token(created_attacker.email)
    headers = {"Authorization": f"Bearer {token}"}

    # 4. Attacker tries to delete Owner's project
    response = await client.delete(f"/api/v1/projects/{created_project.id}", headers=headers)

    # 5. Assert Forbidden (403) or Not Found (404)
    # Ideally should be 403 or 404 depending on implementation security
    assert response.status_code in [403, 404]
    
    # Verify project still exists
    saved_project = await project_repo.get_by_id(created_project.id)
    assert saved_project is not None

@pytest.mark.asyncio
async def test_delete_other_user_task_in_other_project(client: AsyncClient, db_session: AsyncSession):
    user_repo = SqlAlchemyUserRepository(db_session)
    project_repo = SqlAlchemyProjectRepository(db_session)
    task_repo = SqlAlchemyTaskRepository(db_session)

    # 1. Setup Users
    owner = User(email="owner2@example.com", password_hash="hashed_pw", full_name="Owner2", is_active=True)
    attacker = User(email="attacker2@example.com", password_hash="hashed_pw", full_name="Attacker2", is_active=True)
    
    created_owner = await user_repo.create(owner)
    created_attacker = await user_repo.create(attacker)

    # 2. Setup Project & Task for Owner
    project = Project(
        key="PRJ", 
        name="P", 
        start_date=datetime.now(), 
        methodology=Methodology.KANBAN, 
        manager_id=created_owner.id
    )
    created_project = await project_repo.create(project)
    
    task = Task(
        title="Secret Task",
        priority=TaskPriority.HIGH,
        project_id=created_project.id,
        status_id=1 # Assuming status ID 1 exists (Backlog)
    )
    created_task = await task_repo.create(task)

    # 3. Attacker Login
    token = create_test_token(created_attacker.email)
    headers = {"Authorization": f"Bearer {token}"}

    # 4. Attacker tries to delete task
    response = await client.delete(f"/api/v1/tasks/{created_task.id}", headers=headers)
    
    assert response.status_code in [403, 404]

@pytest.mark.asyncio
async def test_access_my_tasks(client: AsyncClient, db_session: AsyncSession):
    user_repo = SqlAlchemyUserRepository(db_session)
    task_repo = SqlAlchemyTaskRepository(db_session)
    
    user = User(email="me@example.com", password_hash="hashed", full_name="Me", is_active=True)
    created_user = await user_repo.create(user)
    
    # We need a project to create a task usually, unless tasks can be orphan
    # Assuming tasks need a project, let's create a dummy one or use a nullable project_id if allowed
    # Based on entities, project_id is usually required. Let's create a dummy project.
    project_repo = SqlAlchemyProjectRepository(db_session)
    project = Project(key="MY", name="My P", start_date=datetime.now(), methodology=Methodology.SCRUM, manager_id=created_user.id)
    created_project = await project_repo.create(project)
    
    # Create task assigned to me
    task = Task(
        title="My Task", 
        project_id=created_project.id, 
        assignee_id=created_user.id,
        status_id=1
    )
    created_task = await task_repo.create(task)
    
    token = create_test_token(created_user.email)
    headers = {"Authorization": f"Bearer {token}"}
    
    response = await client.get("/api/v1/tasks/my-tasks", headers=headers)
    
    assert response.status_code == 200
    data = response.json()
    # Depending on response structure, check list
    # The endpoint returns List[TaskResponseDTO]
    assert len(data) >= 1
    found_ids = [t["id"] for t in data]
    assert created_task.id in found_ids